<div class="chapter">
  <h2 class="break">Anwendungsbereiche</h2>

  <h3>Computergrafik</h3>

  <h4>Kollisionsdetektion</h4>
  <p>
    Raumunterteilung ist ein hilfreiches Werkzeug um in Computerspielen oder sonstigen Computersimulationen mit einer 2D
    oder 3D Grafik Collision Detection zu realisieren. Um zu detektieren welche Einheiten gerade in der Nähe des
    Hauptgebäudes sind kann man entweder naiv mit Brute Force durch die Liste aller Einheiten im Spiel iterieren oder
    man verwendet einen raumunterteilenden Baum um die Einheiten schnell mit einer Komplexität von O(log N) zu finden.
  </p>

  <h4>Nearest Neighbor</h4>
  <p>
    Um eine gewisse Anzahl an nächstgelegenen Nachbaren zu finden wird ein k-nearest neighbor (k-NN) Algorithmus
    verwendet. Ein k-NN Algorithmus klassifiziert Datenpunkte in einer Menge zu Gruppen.
  </p>

  <figure>
    <img src="images/knn.png">
    <figcaption>k nearest neighbor Suche</figcaption>
    <span class="source">Quelle: <a href="#ref-wikipedia-knn">Wikipedia: k-nearest neighbor algorithm</a></span>
  </figure>

  <p>
    Seit 1970 wurde die Branch and Bound Methode verwendet um das Problem zu lösen. Branch and Bound wird für
    Natürliche-Zahlen-Optimierungsprobleme angewendet. Also für Probleme in welchen die Variablen natürliche Zahlen
    sind. Häufig, aber nicht immer, sind die Variablen 1 oder 0. Ein Beispiel dafür wäre das Knapsack Problem auf
    welches ich jetzt nicht weiter eingehe.
  </p>

  <p>
    Mehrere raumunterteilende Methoden wurden entwickelt um die Nearest Neighbor Suche zu lösen, eine davon,
    wahrscheinlich die einfachste, heisst <a href="#kd-tree">Kd Tree</a>. Der Kd Tree unterteilt den Suchraum iterativ
    in zwei Unterräume die je die Hälfte der Punkte enthalten. Dieser ist jedoch nicht sehr geeignet, wenn sich der
    Suchraum dynamisch verändert. Deshalb wurde der <a href="#r-tree">R Tree</a> entwickelt, welcher effiziente
    Algorithmen für das Einfügen und Löschen von Punkten hat.
  </p>

  <h4>Ray Tracing</h4>
  <p>
    In Ray Tracing Applikationen werden Strahlen durch jeden anzuzeigenden Pixel geschossen um zu berechnen welche Farbe
    es hat. Das ist offensichtlich ohne weitere Optimierungen kaum in Echtzeit lösbar. Verbesserungen der Performance
    können durch die Wahl von optimalen Kollisionsgeometrien, moderne Implementationen von Schnittpunktalgorithmen mit
    Object Bounding und Volumen sowie durch parallele Berechnung gewonnen werden. Ein grosser Gewinn an Performance
    erhält man durch die Benutzung einer raumunterteilenden Datenstruktur. Die einfachste Möglichkeit ist ein uniformes
    Raster. Dies ist einfach zu implementieren und hat fast keinen Verwaltungsaufwand. Mit <a href="#kd-tree">Kd
    Trees</a> oder Octrees kann aber noch mehr herausgeholt werden.
  </p>

  <h4>Portal Culling</h4>
  <p>
    In 3D Anwendungen gibt es häufig eine grosse Menge an Geometrien, die gezeichnet werden müssen, um die Szene
    darzustellen. Damit nicht immer alles gezeichnet werden muss, kann Portal Culling zur Anwendung gebracht werden.
    Simpel gesagt werden nur die Welt-Sektionen gezeichnet die durch ein Portal sichtbar sind. Das ist relativ einfach
    vorstellbar bei Ur-Klassikern wie Doom oder Wolfenstein 3D. Nur was durch ein Portal sichtbar ist muss auch
    gezeichnet werden. Um das zu berechnen werden raumunterteilende Datenstrukturen verwendet. Portal Culling wird auch
    in den modernsten Game Engines angewendet wie z.B. der <a href="#ref-cryengine-portal-culling">CRYENGINE</a>.
  </p>

  <figure class="affix">
    <img src="images/portal-culling.png">
    <figcaption>Portal Culling, Vogelperspektive</figcaption>
    <span class="source">Quelle: <a href="#ref-portal-culling">Panda3D: Portal Culling</a></span>
  </figure>

  <h3>Leiterplattenprüfung</h3>
  <p>
    Raumunterteilende Algorithmen und Datenstrukturen werden nicht ausschliesslich für Computeranwendungen gebraucht.
    Auch Designer von Leiterplatten verwenden raumunterteilende Methoden um sicherzustellen, dass die entworfene Platte
    auch herstellbar ist. Diese Überprüfung stellt fest ob unter Berücksichtigung der Leiterbreite und die nötigen
    Abstände dazwischen eingehalten wurden. Ein modernes Design kann Milliarden von Polygonen haben die Kabel und
    Transistoren repräsentieren.
  </p>
</div>

<p id="ref-wikipedia-knn" class="reference-item">
  <span class="ref">Wikipedia: k-nearest neighbors algorithm</span>
  <a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" target="_blank">https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm</a>
  <span class="retreived">12. Mai 2017</span>
</p>

<p id="ref-cryengine-portal-culling" class="reference-item">
  <span class="ref">CRYENGINE: Culling Explained</span>
  <a href="http://docs.cryengine.com/display/SDKDOC4/Culling+Explained" target="_blank">http://docs.cryengine.com/display/SDKDOC4/Culling+Explained</a>
  <span class="retreived">6. Mai 2017</span>
</p>

<p id="ref-portal-culling" class="reference-item">
  <span class="ref">Panda3D - Portal Culling</span>
  <a href="https://www.panda3d.org/manual/index.php/Portal_Culling" target="_blank">https://www.panda3d.org/manual/index.php/Portal_Culling</a>
  <span class="retreived">12. Mai 2017</span>
</p>
